# -*- coding: utf-8 -*-
"""
Created on Tue Feb 20 10:12:44 2018

@author: asp
"""
import copy
import random
from collections import defaultdict
from nltk import Tree


class CFG(object):
    """
    Context-Free Grammar. Store productions from pre-parsed sentences for
    random text generation

    Args:
        TODO

    Returns:
        TODO

    Raises:
        TODO

    """


    def __init__(self):
        # production: { 'NP' : [ ('NN',), ('ADJ', 'NN') ] }
        self.productions = defaultdict(list)


    def add_production(self, lhs, rhs):
        """
        Add single production to CFG. Multiple terminal symbols can be
        separated with a "|" character.

        Adapted from public domain code in "Generating random sentences from a
        context free grammar" blog post © 2003-2018 Eli Bendersky
        https://eli.thegreenplace.net/2010/01/28/generating-random-sentences-
            from-a-context-free-grammar

        Examples:
            'S' -> 'NP VP'
            'NP' -> 'I' | 'you'

            Can't handle multi-word terminal symbols:
                'ADJ' -> 'blue and green' will become 'ADJ' -> 'blue' | 'and' |
                'green'


        Args:
            lhs (str): Nonterminal symbol to expand into rhs
            rhs (str): Terminal or Nonterminal symbol to which lhs can be
                expanded.

        Returns:
            None: class variable mutated

        Raises:
            # TODO
        """

        # Add each pipe-delimited part of rhs to cfg
        # Append rule tuple to autogenerated list
        for symbol in rhs.split('|'):
            symbol = symbol.strip()  # handle ' | ' and '|'
            self.productions[lhs].append(tuple(symbol.split()))


    def expand(self, symbol, alpha=0.25):
        """
        Initialize a dict which will contain weights for each production used at
        each level of recursion. rule_weights is passed by shallow copy between
        levels of recursion to avoid mutating an upper level's weights.

        Adapted from public domain code in "Generating random sentences from a
        context free grammar" blog post © 2003-2018 Eli Bendersky
        https://eli.thegreenplace.net/2010/01/28/generating-random-sentences-
            from-a-context-free-grammar

        Args:
            symbol (str): The symbol from which to begin expansion. Must be
            contained in self.productions

            self.productions (dict): Nonterminal symbols and their expansion
                                     possibilities
                key: str
                value: list of tuples

                ex. self.productions = {
                        'S': [('S', 'NP'),       # Possible expansions
                            ('S', 'S', 'VP'),  # ...
                            ('NP', 'VP')],     # ...
                        'NP': [...],
                        ...}

            alpha (float): Penalization parameter for repeated expansions.
            Alpha is multiplied by the previous probability of a chosen
            expansion, so probability of repeated expansion decreases as value
            decreases.

                    P = alpha ** N

                    where P is probability of expansion being chosen
                        N is number of times the rule has been expanded in the
                            current depth-first traversal.
                        0 < alpha < 1.0

        Returns:
            tuple of str: A grammatical sentence according to CFG
        """

        rules = copy.copy(self.productions)  # avoid mutating CFG class object
        rule_weights = {}  # Initialize dict values to 1.0

        def recurse(symbol, rule_weights):
            sentence = ()

            # Initialize nonterminal expansion weights
            if symbol not in rule_weights:
                rule_weights[symbol] = [1.0,] * len(rules[symbol])
            # else, they're already set in an upper recursion level

            expansion = random.choices(population=rules[symbol],
                                       weights=rule_weights[symbol],
                                       k=1)[0]  # NOTE Assumes len(list) == 1

            # Decrease future probability of chosen rule
            # NOTE Assumes only one match of expansion in self.productions
            # [symbol]
            rule_weights[symbol][rules[symbol].index(expansion)] *= alpha

            for rhs_symbol in expansion:
                if rhs_symbol in rules:  # nonterminal symbol
                    sentence += recurse(rhs_symbol, copy.copy(rule_weights))

                else:  # terminal symbol
                    sentence += (rhs_symbol,)

            return sentence

        return recurse(symbol, rule_weights)


    def nltk_expand(self, nonterminal, alpha=0.25):
        """
        Initialize a dict which will contain weights for each production used at
        each level of recursion. rule_weights is passed by shallow copy between
        levels of recursion to avoid mutating an upper level's weights.

        Adapted from public domain code in "Generating random sentences from a
        context free grammar" blog post © 2003-2018 Eli Bendersky
        https://eli.thegreenplace.net/2010/01/28/generating-random-sentences-
            from-a-context-free-grammar

        Args:
            nonterminal (nltk.Nonterminal): The symbol from which to begin
                expansion. Must be contained in self.productions

            self.productions (dict): Nonterminal symbols and their expansion
                                     possibilities
                key: str
                value: list of tuples

                ex. self.productions = {
                        'S': [('S', 'NP'),       # Possible expansions
                            ('S', 'S', 'VP'),  # ...
                            ('NP', 'VP')],     # ...
                        'NP': [...],
                        ...}

            alpha (float): Penalization parameter for repeated expansions.
            Alpha is multiplied by the previous probability of a chosen
            expansion, so probability of repeated expansion decreases as value
            decreases.

                    P = alpha ** N

                    where P is probability of expansion being chosen
                        N is number of times the rule has been expanded in the
                            current depth-first traversal.
                        0 < alpha < 1.0

        Returns:
            tuple of str: A grammatical sentence according to CFG
        """

        rules = copy.copy(self.productions)  # avoid mutating cfg
        rule_weights = {}  # Initialize dict values to 1.0

        def recurse(symbol, rule_weights):
            sentence = ()

            # Initialize nonterminal expansion weights
            if symbol not in rule_weights:
                rule_weights[symbol] = [1.0,] * len(rules[symbol])
            # else, they're already set in an upper recursion level

            # print('rules[Nonterminal('+str(symbol)+')]=', rules[symbol])
            # print('rule_weights['+str(symbol)+']=', rule_weights[symbol])
            expansion = random.choices(population=rules[symbol],
                                       weights=rule_weights[symbol],
                                       k=1)[0]  # NOTE Assumes len(list) == 1

            # Decrease future probability of chosen rule
            # NOTE Assumes only one match of expansion in self.productions
            # [symbol]
            rule_weights[symbol][rules[symbol].index(expansion)] *= alpha

            for rhs_symbol in expansion:
                if rhs_symbol in rules:  # nonterminal symbol
                    # print(rhs_symbol, rule_weights[symbol][rules[symbol].index(expansion)])
                    sentence += recurse(rhs_symbol, copy.copy(rule_weights))

                else:  # terminal symbol
                    sentence += (rhs_symbol,)

            return sentence

        return recurse(nonterminal, rule_weights)


    # Deprecated
    def stringify_nltk_tree(self, tree):
        """
        Convert NLTK Tree.productions() into raw Python types. Interfaces with CFG class. Does not mutate parameters.

        Args:
            tree (nltk.Tree): NLTK data structure containing productions
        Returns:
            list(tuple(str)): List of production tuples. Symbols are str.
                            ex. [('lhs', 'rhs'),
                                ('lhs', 'rhs')]
        """
        # nltk.Tree
        assert isinstance(tree, Tree), 'tree parameter is not a nltk.Tree class'

        list_o_rules = [tuple(str(rule).replace("'", '').split(' -> ')) for
                        rule in tree.productions()]

        return list_o_rules

    # Deprecated
    def add_nltk_tree(self, tree):
        """
        Convenience method for adding productions to CFG directly from a NLTK
        Tree. Call to stringify_nltk_tree()

        Args:
            tree (nltk.Tree): NLTK data structure containing productions
        Returns:
            None: mutates self (CFG.productions)
        """
        list_o_rules = self.stringify_nltk_tree(tree)

        for rule in list_o_rules:
            self.add_production(rule[0], rule[1])
